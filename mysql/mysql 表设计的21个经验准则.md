

微信公众号看到一篇文章总结了mysql 工作中的21个设计经验准则。

from : [21 个 MySQL 表设计的经验准则](https://mp.weixin.qq.com/s/OlP0FVnLO_xw7jlahIVOMA)

# 1、命名规范

命名规范是指对数据库，表，字段，索引的规范。每个公司或团队都是自己的命名规范，这和代码命名是一致的。

一般要可读性高，让用者一看就知道是什么意义。 

-   表名、字段名必须使用小写字母或者数字，禁止使用数字开头，禁止使用拼音，并且一般不使用英文缩写。
-   主键索引名为 pk_字段名 ；唯一索引名为 uk_ 字段名；普通索引名则为 idx_字段名。

# 2、选择合适的字段类型

设计表时，我们要选择合适的字段类型。 

-   尽可能选择存储空间小的字段类型，就好像数字类型的，从 tinyint、smallint、int、bigint 从左往右开始选择。
- 小数类型如金额，则选择  **decimal** ，禁止使用  float  和 double。
- 如果存储的字符串长度几乎相等，使用  char  定长字符串类型。一般要要求业务定下最长字符。
-  varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000。所有 varchar 字段的长度加起来，不能大于 65535。
- 如果存储的值太大，建议字段类型修改为 text，同时抽出单独一张表，用主键与之对应。

# 3、主键设计要合理

主键最好是毫无意义的一串独立不重复的数字，比如 UUID，又或者 Auto_increment 自增的主键，或者是雪花算法生成的主键等等;

雪花算法： [面试官：讲讲雪花算法，越详细越好](https://zhuanlan.zhihu.com/p/433690272)

# 4、选择合适的长度

mysql 中， varchar 和 char 类型表示字符长度，而其他类型表示的长度都表示字节长度。比如 char(10) 表示字符长度是10，而 bigint（4）表示显示长度是4个字节，但是因为 bigint 实际长度是8个字节，所以bigint（4）的实际长度就是8个字节。

字段长度一般设置为2的幂（也就是2的n 次方）。


# 5、优先考虑逻辑删除，而不是删除

一般不做数据删除，而是更新状态，把数据标志为已删除状态。

但是当业务已经下线，不在用了，且数据已经备份或者已经同步到了集市了，一般会考虑让 DBA 删除，减少数据库的压力。

-  物理删除：把数据从硬盘中删除，可释放存储空间。
- 逻辑删除：给数据添加一个字段，比如 is_deleted，以标记该数据已经逻辑删除。

# 6、每个表都需要添加几个通用字段

数据库表，要存在一些字段，没有直接业务意义，但却很重要。如：主键、create_time, update_time, ext等。

如下：

-   id：主键，一个表必须得有主键，可以自增长。
-  create_time ：数据创建时间。
-  modifed_time: 修改时间，当数据被增量拉到数据集市时，这个字段是必段的。
-  version : 数据记录的版本号，用于乐观锁。
-  ext : 扩展字段，当有紧急情况时，可以先暂用它，而不会更新表结构。
-  remark ：数据记录备注。
-  modified_by :修改人， 非必须
-  creator ：创建人，非必须

# 7、一张表的字段不宜过多


表的字段不宜过多，过多可能会导致数据库性能问题。表的字段应该是多少，最好根据业务情况而定，可用用领域设计来划分业务范围。



# 8、尽可能使用 NOT NULL 定义字段

创建表时，所有的字段应该都是 `NOT NULL DEFAULT '' `。非空且有默认值。这应该成为一种规范。

可以看：[[mysql  常用语句]] 的表创建。

原因：

- NULL 值存储也需要额外的空间的，它也会导致比较运算更为复杂，使优化器难以优化SQL。
- NULL 值有可能会导致索引失效。

# 9、设计表时，评估哪些字段需要加索引

对于索引的考量，是设计表一个重点。mysql 索引的相关的知识 

[[mysql 索引]]

[MySQL 索引知识点总结](https://mp.weixin.qq.com/s/QduIxKOykMmoZp13UGF1XQ) or [[mysql 索引知识点总结]]


-   索引也不要建得太多，一般单表索引个数不要超过`5`个。因为创建过多的索引，会降低写得速度。
-   区分度不高的字段，不能加索引。（还是要看业务的具体情况矶定。）
-   索引创建完后，还是要注意避免索引失效的情况。
-   索引过多的话，可以通过联合索引的话方式来优化。然后的话，索引还有一些规则，如**覆盖索引**，最左匹配原则等等。


# 10、不需要严格遵守 3NF，通过业务字段冗余来减少表的关联

什么是数据库三范式（3NF）

-   第一范式：对属性的原子性，要求属性具有原子性，不可再分解；
-   第二范式：对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖；
-   第三方式：对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；

系统设计中，对一范式的要求基本没有讲究过。比较在意的是设计能否保证上服务的**高性能**。为了提高性能，冗余一些数据也是正常的事。

从数据原型出发，分析业务数据的读写情况，从而决定是表字段的大小。能减少表的关联尽量少到表的关联。 



# 11、避免使用 mysql 保留字

这是一个基本的常识，做开发的应该都知道保留字段避免使用。 会被用的估计是不小心用到了但不知道你这个保留字。

# 12、不搞外键关联，一般都在代码维护

外键，也叫  FOREIGN KEY ，它是用于将两个表连接在一起的键。FOREIGN KEY 是一个表中的一个字段（或字段集合），它引用另一个表中的  PRIMARY KEY。它是用来保证数据的一致性和完整性的。

不搞外键，一般在可以在业务层面上搞定的就行了。这应该是一个编程规范。

外键破坏了数据库的扩展性，当以后要分库分表时，就很难办了。 

# 13、一般都选择 InnoBD 存储引擎

用什么引擎这是DBA的事了。现在 mysql 默认的都是 InnoDB。应该不会有人在这个样上去搞事情了。

[[mysql InnoDB 引擎]]


# 14、选择合适统一的字符集

字符集一定要定好，特别我们用到很多的中文。有一些情况是，开发人员会在业务代码层面去改变这个字符集。这个也应该被禁止掉。 在工作经历中，发生过事故。mysql 链接发生重连后，就回到原来的字符集了。可能会出乱码的情况。

用python 开发时，也同样被中文的字符集问题搞晕了很多次。 

数据库库、表、开发程序等都需要统一字符集，通常中英文环境用`utf8`。

MySQL支持的字符集有 utf8、utf8mb4、GBK、latin1 等。

-   utf8：支持中英文混合场景，国际通过，3个字节长度
-   utf8mb4:   完全兼容utf8，4个字节长度，一般存储**emoji表情**需要用到它。
-   GBK ：支持中文，但是不支持国际通用字符集，2个字节长度
-   latin1：MySQL默认字符集，1个字节长度


# 15、如果你的数据库字段枚举类型的，需要在comment 注释清楚

comment 注释清楚所有字段，这是方便以后的维护。更进一步讲，增加新字段时，要写清楚对应的业务版本。

字段是枚举类型，就更应该写清楚了。


# 16、 时间的类型选择

对于MySQL来说，主要有 date、datetime、time、timestamp 和 year。

-   date ：表示的日期值, 格式`yyyy-mm-dd`,范围`1000-01-01 到 9999-12-31`，3字节
-   time ：表示的时间值，格式 `hh:mm:ss`，范围`-838:59:59 到 838:59:59`，3字节
-   datetime：表示的日期时间值，格式`yyyy-mm-dd hh:mm:ss`，范围`1000-01-01 00:00:00到`9999-12-31 23:59:59```,8字节，跟时区无关
-   timestamp：表示的时间戳值，格式为`yyyymmddhhmmss`，范围`1970-01-01 00:00:01到2038-01-19 03:14:07`，4字节，跟时区有关
-   year：年份值，格式为`yyyy`。范围`1901到2155`，1字节
    

推荐优先使用 datetime 类型来保存日期和时间，因为存储范围更大，且跟时区无关。

**要注意的是 timestamp 的单位是秒不是毫秒。**

# 17、不建议 Stored procedure (包括存储过程，触发器)

对于MYSQL来说，存储过程、触发器等还不是很成熟， 并没有完善的出错记录处理，不建议使用。

尽量在业务代码中完成这一些逻辑。 


# 18、1:n 关系的设计

日常开发中，1 对多的关系应该是非常常见的。比如一个班级有多个学生，一个部门有多个员工等等。这种的建表原则就是：在从表（ N 的这一方）创建一个字段，以字段作为外键指向主表（ 1 的这一方）的主键。

有时候两张表存在 N:N 关系时，我们应该消除这种关系。通过增加第三张表，把 N:N 修改为两个  1:N 。比如图书和读者，是一个典型的多对多的关系。一本书可以被多个读者借，一个读者又可以借多本书。我们就可以设计一个借书表，包含图书表的主键，以及读者的主键，以及借还标记等字段。

# 19、大字段

字段太大了，不要存入 mysql中。可以选择另外的存储。 如图片，文体，可以通过放到 CDN 上。然后保存 对应的链接到 mysql 表中。



# 20、考虑是否需要分库分表

分库分表是在业务发一定量时要做的事情。 我们在早期的系统设计时就要依据业务需求量做出评估。如果后期有这个需要，在设计是就是充分考虑进去。 

一个不利于分库分表的就不要做，如外键。用什么维度去分也要考虑清楚。 

-  分库：就是一个数据库分成多个数据库，部署到不同机器。
- 分表：就是一个数据库表分成多个表。

分库分表主要有水平拆分、垂直拆分的说法，拆分策略有 range范围、hash取模。而分库分表主要有这些问题：

-   事务问题
-   跨库关联
-   排序问题
-   分页问题
-   分布式ID

# 21、 sql 编写的一些优化经验

1）不要用 `select * ` , 而是要指定具体的字段。这样不被业务的代码需要的字段就没有必要被读出。随着业务的发展可能会有新增字段，导致业务代码的不可控。

2）如是业务上已要求结果只有一条，加了 `limit 1`。业务上对数据有惟一的要求，一定要通过严格的条件过滤出来。 优先通过 SQL 语言过滤，再考虑业务代码过滤。

3）应尽量避免在 where 子句中使用 or 来连接条件。or 会破坏索引，但select 时要时刻注意索引是否有效，要评估效率。

4）注意优化 limit 深分页问题。[mysql 证明为什么用limit时，offset很大会影响性能](https://github.com/zhangyachen/zhangyachen.github.io/issues/117)

5）使用 where 条件限定要查询的数据，避免返回多余的行。同 2。

6）尽量避免在索引列上使用 mysql 的内置函数，在where上使用索引，可能会破坏索引，破坏索引。

7）应尽量避免在  where 子句中对字段进行表达式操作。尽量把运算好之后的结果做为 where 的条件。

8）应尽量避免在 where  子句中使用`!=`或`<>`操作符。破坏索引，破坏索引。

9）使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。

10） 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引。

11）如果插入数据过多，考虑批量插入。无论是插入或查询，都要根据业务情况，考虑批量，分批处理。可能因为极端条件导致性能问题。

12）在适当的时候，使用覆盖索引。[什么是覆盖索引](https://zhuanlan.zhihu.com/p/339666157)

13）使用 explain 分析你SQL的计划。